import type { CollectionSchema, FieldDefinition, SchemaDefinition } from "../migration/types";

export interface TypeGeneratorConfig {
  outPath?: string;
}

const PASCAL_CASE_REGEX = /(?:^\w|[A-Z]|\b\w)/g;
const WORD_SEPARATOR_REGEX = /[\s_-]+/g;

export class TypeGenerator {
  private schema: SchemaDefinition;

  constructor(schema: SchemaDefinition) {
    this.schema = schema;
  }

  public generate(): string {
    const lines: string[] = [];

    // Add header
    lines.push(`/**`);
    lines.push(` * This file was auto-generated by pocketbase-zod-schema.`);
    lines.push(` * Do not modify it manually.`);
    lines.push(` */`);
    lines.push(``);

    // Check if RecordModel is needed (used as fallback for relations to collections not in schema)
    const needsRecordModel = this.checkIfRecordModelNeeded();

    if (needsRecordModel) {
      lines.push(`import type { RecordModel } from "pocketbase";`);
      lines.push(``);
    }

    // Generate types for each collection
    const collectionNames = Array.from(this.schema.collections.keys());

    for (const [_, collection] of this.schema.collections) {
      lines.push(this.generateCollectionType(collection));
      lines.push(``);
    }

    // Generate CollectionResponse map
    lines.push(`export type CollectionResponses = {`);
    for (const name of collectionNames) {
      const typeName = this.toPascalCase(name);
      lines.push(`  ${name}: ${typeName}Response;`);
    }
    lines.push(`};`);
    lines.push(``);

    // Generate TypedPocketBase interface
    lines.push(`import PocketBase from "pocketbase";`);
    lines.push(`import { RecordService } from "pocketbase";`);
    lines.push(``);
    lines.push(`export interface TypedPocketBase extends PocketBase {`);
    lines.push(`  collection(idOrName: string): RecordService;`); // Fallback`);
    for (const name of collectionNames) {
      const typeName = this.toPascalCase(name);
      lines.push(`  collection(idOrName: "${name}"): RecordService<${typeName}Response>;`);
    }
    lines.push(`}`);
    lines.push(``);

    return lines.join("\n");
  }

  private generateCollectionType(collection: CollectionSchema): string {
    const typeName = this.toPascalCase(collection.name);
    const lines: string[] = [];

    // Generate Record Interface (base fields)
    lines.push(`export interface ${typeName}Record {`);

    // System fields
    lines.push(`  id: string;`);
    lines.push(`  created: string;`);
    lines.push(`  updated: string;`);
    lines.push(`  collectionId: string;`);
    lines.push(`  collectionName: "${collection.name}";`);

    // User fields
    for (const field of collection.fields) {
      // Skip system fields if they are explicitly in the fields list (they shouldn't be, but just in case)
      if (['id', 'created', 'updated'].includes(field.name)) continue;

      const fieldType = this.getFieldType(field);
      const optional = !field.required ? "?" : "";
      lines.push(`  ${field.name}${optional}: ${fieldType};`);
    }

    lines.push(`}`);
    lines.push(``);

    // Generate Response Interface (with expand)
    lines.push(`export interface ${typeName}Response extends ${typeName}Record {`);

    // Calculate expand type
    const expandFields: string[] = [];
    for (const field of collection.fields) {
      if (field.type === 'relation' && field.relation) {
        const targetCollection = field.relation.collection;
        // Check if target exists in schema or is system collection
        let targetType = 'RecordModel'; // Fallback

        if (targetCollection.toLowerCase() === 'users' && !this.schema.collections.has('users')) {
            // If users collection is not in our schema but referenced, assume standard Auth collection
            // Or if it IS in schema, we use it.
            // Often 'users' is implicit. If we don't have it, we might want to generate a placeholder or use 'any'.
            // For now, let's try to map to generated type if exists, else RecordModel
        }

        if (this.schema.collections.has(targetCollection)) {
            targetType = `${this.toPascalCase(targetCollection)}Response`;
        } else if (targetCollection === 'users') {
            // Attempt to handle 'users' if it's not explicitly defined but referenced
            // Check if we generated a 'UsersResponse'. If not, we might be in trouble.
            // But usually 'users' is part of the schema if we are managing it.
            // If not, we fall back to RecordModel or generic.
            // Let's assume if it's missing, we use RecordModel
             targetType = 'RecordModel';
        }

        const isMultiple = (field.relation.maxSelect ?? 1) > 1;
        const expandType = isMultiple ? `${targetType}[]` : targetType;

        // Relation field name in expand is same as field name
        // However, it is optional in the response if not expanded
        expandFields.push(`${field.name}?: ${expandType}`);
      }
    }

    if (expandFields.length > 0) {
      lines.push(`  expand?: {`);
      for (const ef of expandFields) {
        lines.push(`    ${ef};`);
      }
      lines.push(`  };`);
    }

    lines.push(`}`);

    return lines.join("\n");
  }

  private getFieldType(field: FieldDefinition): string {
    switch (field.type) {
      case 'text':
      case 'email':
      case 'url':
      case 'editor':
      case 'date':
      case 'autodate':
        return 'string';

      case 'number':
        return 'number';

      case 'bool':
        return 'boolean';

      case 'json':
        return 'any';

      case 'file':
        if (field.options?.maxSelect && field.options.maxSelect > 1) {
          return 'string[]';
        }
        return 'string';

      case 'select':
        if (field.options?.values && Array.isArray(field.options.values) && field.options.values.length > 0) {
          const union = field.options.values.map((v: string) => `"${v}"`).join(' | ');
          if (field.options?.maxSelect && field.options.maxSelect > 1) {
            return `(${union})[]`;
          }
          return union;
        }
        if (field.options?.maxSelect && field.options.maxSelect > 1) {
          return 'string[]';
        }
        return 'string';

      case 'relation':
        if (field.relation?.maxSelect && field.relation.maxSelect > 1) {
          return 'string[]';
        }
        return 'string';

      default:
        return 'any';
    }
  }

  private toPascalCase(str: string): string {
    return str
      .replace(PASCAL_CASE_REGEX, (word) => {
        return word.toUpperCase();
      })
      .replace(WORD_SEPARATOR_REGEX, '');
  }

  /**
   * Checks if RecordModel is needed as a fallback type for relations
   * to collections that don't exist in the schema
   */
  private checkIfRecordModelNeeded(): boolean {
    for (const [_, collection] of this.schema.collections) {
      for (const field of collection.fields) {
        if (field.type === 'relation' && field.relation) {
          const targetCollection = field.relation.collection;
          // If target collection is not in schema, RecordModel will be used
          if (!this.schema.collections.has(targetCollection)) {
            return true;
          }
        }
      }
    }
    return false;
  }
}
